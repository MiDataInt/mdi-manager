#!/bin/bash

# the main executable script that 
#   - establishes the job manager
#   - makes calls that execute pipelines
#   - provides a command line shortcut to mdi::run(), etc. 

#----------------------------------------------------------------------
# input arguments
#----------------------------------------------------------------------
export DEVELOPER_MODE=""
TARGET=$1
if [ "$TARGET" = "develop" ]; then
    export DEVELOPER_MODE="TRUE"
    shift    
    TARGET=$1
fi
if [[ "$TARGET" = "-h" ||  "$TARGET" = "--help" ||  "$TARGET" = "help" ]]; then TARGET=""; fi
export MDI_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

#----------------------------------------------------------------------
# Stage 2 shortcuts to mdi R functions via Rscript
#----------------------------------------------------------------------

# TODO: move these commands to the job manager so that options can be properly handled

# shortcut for launching the web server
if [ "$TARGET" = "server" ]; then
    MODE=$2 # any function exported by mdi R package, e.g., run, develop
    if [ "$MODE" = "" ]; then MODE="run"; fi # default to run if action not specified
    exec Rscript -e "mdi::$MODE('$MDI_DIR')"
    
# shortcut for re-installing the MDI (could also use 'mdi server install')
elif [ "$TARGET" = "install" ]; then
    exec Rscript -e "mdi::install('$MDI_DIR')"

#----------------------------------------------------------------------
# Stage 1 pipeline execution via the job manager
#----------------------------------------------------------------------
else

# use developer fork of mdi-pipelines-framework if present and in developer mode
export FRAMEWORK_DIR=$MDI_DIR/frameworks/developer-forks/mdi-pipelines-framework
if [[ ! -d $FRAMEWORK_DIR || "$DEVELOPER_MODE" != "TRUE" ]]; then 
    export FRAMEWORK_DIR=$MDI_DIR/frameworks/definitive/mdi-pipelines-framework
fi

# set script paths
export JOB_MANAGER_DIR=$FRAMEWORK_DIR/job_manager
JOB_MANAGER_TARGET=$JOB_MANAGER_DIR/jobManager
JOB_MANAGER_COMMANDS=$(cd $JOB_MANAGER_DIR/lib/commands && ls -1 *.pl |  cut -d '.' -f 1 | tr '\n' ' ') 

# set pipelines suites - these values are programatically filled by mdi::install()
export PIPELINES_SUITE_NAMES="_PIPELINES_SUITE_NAMES_" # space delimited list

# handle a direct call to initialize the job manager (called by mdi::install())
if [ "$TARGET" = "initialize" ]; then
    echo "  $JOB_MANAGER_DIR"
    exec perl $JOB_MANAGER_DIR/initialize.pl $MDI_DIR

# handle job manager functions (submit, report, etc.)
# also handle mdi called with no arguments
elif [[ "$TARGET" = "" || " $JOB_MANAGER_COMMANDS " =~ " $TARGET " ]]; then
    
    # ensure that the job manager target script has been initialized
    if [ ! -e "$JOB_MANAGER_TARGET" ]; then
        perl $JOB_MANAGER_DIR/initialize.pl $MDI_DIR
    fi    

    # fork the call to the job manager utility (a close relative of 'q')
    if [ -e "$JOB_MANAGER_TARGET" ]; then
        if [ "$TARGET" = "" ]; then
            exec $JOB_MANAGER_TARGET # various routes to mdi top-level help
        else 
            exec $JOB_MANAGER_TARGET "$@"
        fi
    fi

# capture and pass calls to a pipeline when using job manager as a surrogate
# thus, pipelines cannot have the same name as a job manager command (submit, report, etc.)
# launcher.pl handles pipeline target errors
else
    exec perl $FRAMEWORK_DIR/pipeline/launcher/launcher.pl $@ 

fi

fi
